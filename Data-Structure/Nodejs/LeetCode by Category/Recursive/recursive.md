---
marp: true
theme: default
header: 'https://github.com/youngyangyang04/leetcode-master'
footer: 'https://github.com/youngyangyang04/leetcode-master'
paginate: true
size: 16:9
---

# basic

- 递归记录了状态 : `所有过程信息`（`包括第几行、变量信息等`）全部压到栈中，`信息完全保存`
- 递归只是让 解决方案更清晰，并`没有性能上的优势`。实际上，在有些情况下，使用 循环的性能更好
- 调用另一个函数时，当前函数暂停并处于未完成状态 。`该函数的所有变量的值都还在内存中`。
- Haskell 等函数式编程语言 没有循环，因此你只能使用递归来编写这样的函数

---

### 递归行为的实质、如何分析递归行为的时间复杂度

- https://blog.csdn.net/gx17864373822/article/details/112596466
- 递归：自己调用自己
- 递归：压栈
- 递归函数：一个函数调用子过程之前，会把自己的`所有过程信息`（`包括第几行、变量信息等`）全部压到栈中，`信息完全保存`。子过程返回之后，会利用这些信息彻底`还原现场`，继续跑。 跑完之后，再从栈中拿出来一个函数，再还原现场，最终串起来所有子过程和父过程的通信。
- 任何递归行为都可以改为非递归行为：不需要系统压栈，自己压栈，从递归变迭代。

---

# Recursive 三要素

- https://www.youtube.com/watch?v=GOs07Kn2W1E&t=1641s (2:0810)
- https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.md#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86

---

### 基线条件

- 编写涉及`数组的递归函数时`，`基线条件`通常是`数组为空`或`只包含一个元素`。陷入困境时，请检查基线条件是不是这样的。

---

- 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对

- `确定递归函数的参数和返回值`： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。

- 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

---

# 二叉树的算法思想的运用广泛，甚至可以说，只要涉及递归，都可以抽象成二叉树的问题

- 如果需要搜索整颗二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回
- 112. 路径总和, 递归函数是有返回值的，如果递归函数返回 true，说明找到了合适的路径，应该立刻返回。
- 113.路径总和 II 要遍历整个树，找到所有路径，所以递归函数不要返回值！

---

# Master 公式：T(N) = aT(N/b) + O(Nd)

- 适用范围：划分的子过程规模一样
- T(N)：样本量为 N 时的时间复杂度
- T(N/b)：子样本量为 N/b 时的时间复杂度
- a：子过程发生的次数
- O(nd)：除去调用子过程之外，剩下的代价是多少
