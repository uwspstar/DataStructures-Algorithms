---
marp: true
theme: default
header: 'leetcode 位运算'
footer: ''
paginate: true
size: 16:9
---

###

- https://www.liaoxuefeng.com/wiki/1252599548343744/1255888634635520
- https://github.com/selfboot/LeetCode/tree/master/BitManipulation
- https://blog.csdn.net/eff666/article/details/52071252
- http://www.matrix67.com/blog/archives/263
- https://www.zhihu.com/question/38206659
- https://timseverien.github.io/binary-cheatsheet/

---

# 位运算 位运算是按位进行与、或、非和异或的运算。

- 对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算

---

### 与运算的规则是，必须两个数同时为 1，结果才为 1：

- &运算通常用于二进制取位操作，例如一个数 and 1 的结果就是取二进制的最末位。
- 这可以用来判断一个整数的奇偶，二进制的最末位为 0 表示该数为偶数，最末位为 1 表示该数为奇数。

```
n = 0 & 0; // 0
n = 0 & 1; // 0
n = 1 & 0; // 0
n = 1 & 1; // 1
```

---

### 位操作判断奇偶数

​- 只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。

```
if(0 == (a & 1)) {
 //偶数
}
```

---

### 或运算的规则是，只要任意一个为 1，结果就为 1：

- 或运算通常用于二进制特定位上的无条件赋值，例如一个数 or 1 的结果就是把二进制最末位强行变成 1。
- 如果需要把二进制最末位变成 0，对这个数 or 1 之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。

```
n = 0 | 0; // 0
n = 0 | 1; // 1
n = 1 | 0; // 1
n = 1 | 1; // 1
```

---

### 非运算的规则是，0 和 1 互换：

```
n = ~0; // 1
n = ~1; // 0
```

---

### 位操作交换符号

- 交换符号将正数变成负数，负数变成正数
- 整数取反加 1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数

```
int reversal(int a) {
return ~a + 1;
}
```

---

### 异或运算的规则是，如果两个数不同，结果为 1，否则为 0：

- 异或的符号是^。按位异或运算, 对等长二进制模式按位或二进制数的每一位执行逻辑按位异或操作。操作的结果是如果某位不同则该位为 1, 否则该位为 0。
- 异或运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即（a ^ b) ^ b = a。
- ^运算可以用于简单的加密，比如我想对我 MM 说 1314520，但怕别人知道，于是双方约定拿我的生日 19880516 作为密钥。1314520 ^ 19880516 = 20665500，我就把 20665500 告诉 MM。MM 再次计算 20665500 ^ 19880516 的值，得到 1314520，于是她就明白了我的企图。

```
n = 0 ^ 0; // 0
n = 0 ^ 1; // 1
n = 1 ^ 0; // 1
n = 1 ^ 1; // 0
```

- a ^ a = 0

---

```
procedure swap(var a,b:longint);
begin
   a:=a xor b; // a = a ^ b
   b:=a xor b; // b = (a ^ b) ^ b = a
   a:=a xor b; // a = (a ^ b) ^ a = b
end;
```

```
位与操作解释：第一步：a ^= b ---> a = (a^b);

第二步：b ^= a ---> b = b^(a^b) ---> b = (b^b)^a = a

第三步：a ^= b ---> a = (a^b)^a = (a^a)^b = b
```

---

### swap

- 普通操作

```
void swap(int &a, int &b) {
  a = a + b;
  b = a - b;
  a = a - b;
}
```

- 位与操作

```
  void swap(int &a, int &b) {
  a ^= b;
  b ^= a;
  a ^= b;
  }

```

---

### 左移（<<）运算

- a << b 就表示把 a 转为二进制后左移 b 位（在后面添 b 个 0）。a << b 的值实际上就是 a 乘以 2 的 b 次方，因为在二进制数后添一个 0 就相当于该数乘以 2。
- 通常认为 a << 1 比 a \* 2 更快，因为前者是更底层一些的操作。因此程序中乘以 2 的操作请尽量用左移一位来代替。

---

### 右移（>>）运算 ===

- 和左移相似，a >> b 表示二进制右移 b 位（去掉末 b 位），相当于 a 除以 2 的 b 次方（`取整`）。
- 我们也经常用>> 1 来代替除 2，比如二分查找、堆的插入操作等等。想办法用>>代替除法运算可以使程序效率大大提高。

---

### 位操作求绝对值

- https://www.zhihu.com/question/38206659
- 整数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 0xffffffff），然后根据符号进行相应的操作

```
int abs(int a) {
  int i = a >> 31;
  return i == 0 ? a : (~a + 1);
}
```

---

- https://www.zhihu.com/question/38206659
- 上面的操作可以进行优化，可以将 i == 0 的条件判断语句去掉。我们都知道`符号位 i 只有两种情况，即 i = 0 为正，i = -1 为负`。
- 对于任何数与 0 异或都会保持不变，与 -1 即 0xffffffff 进行异或就相当于对此数进行取反,因此可以将上面三目元算符转换为((a^i)-i)，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 0xffffffff 异或将 a 进行取反，然后在加上 1，即减去 i(i =-1)

```
int abs2(int a) {
  int i = a >> 31;
  return ((a^i) - i);
}
```

---

### 位操作进行高低位交换

- https://www.zhihu.com/question/38206659
- 给定一个 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值
- 只要将无符号数 a>>8 即可得到其高 8 位移到低 8 位，高位补 0；将 a<<8 即可将 低 8 位移到高 8 位，低 8 位补 0，然后将 a>>8 和 a<<8 进行或操作既可求得交换后的结果。

```
unsigned short a = 34520;
a = (a >> 8) | (a << 8);
```

---

### 位操作进行二进制逆序

- 将无符号数的二进制表示进行逆序，求取逆序后的结果
- https://www.zhihu.com/question/38206659
- 将奇数位右移一位，偶数位左移一位，此时将两个数据相或即可以达到奇偶位上数据交换的效果：

```
原数：         10000110 11011000
奇数位右移一位： 0 10000010 1000100
偶数位左移一位： 0000100 01010000 0
两数相或得到：   01001001 11100100
```

---

### 位操作统计二进制中 1 的个数

- https://www.zhihu.com/question/38206659

```
count = 0
while(a){
  a = a & (a - 1);
  count++;
}
```

---

- Multiply x by 2k

```
x << k
Example: 5 * 8 = 5 << 3
```

- Divide x by 2k

```
x >> k
Example: 20 / 16 = 20 >> 4
```

- Mod by 2k

```
x & (2k-1)
Example: 20 % 16 = 20 & 15
```

- Is x power of 2?

```
(x != 0) && (x & (x - 1)) == 0
```
