---
marp: true
---

# 剑指 offer 专题

- https://www.nowcoder.com/ta/coding-interviews
- https://zhuanlan.zhihu.com/p/56200260
- https://www.youtube.com/watch?v=rAmd2b3I2y8
- https://www.acwing.com/activity/1/course/
- https://shenlvmeng.github.io/blog/2017/07/27/interview-algorithm-md/
- https://oi-wiki.org/basic/complexity/

---

# 复杂度 基本操作数 + 时间复杂度

- 基本操作数 : 考虑的不是算法运行的实际用时，而是算法运行所需要进行的基本操作的数量。对基本操作的计数或是估测可以作为评判算法用时的指标
- 时间复杂度 : 大 O 符号 关注的通常是程序用时的上界
- 大 Ω 符号, 大 O 符号, 大 Θ 符号

---

# 递归代码最重要的两个特征

- 明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节，
- 结束条件和自我调用 : 自我调用是在解决子问题，而结束条件定义了最简子问题的答案
- 递归的缺点 : 在程序执行中，递归是利用堆栈来实现的。每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧。而栈不是无限大的，当递归层数过多时，就会造成 栈溢出 的后果。

---

# 递归与枚举的区别

- 递归和枚举的区别在于：枚举是横向地把问题划分，然后依次求解子问题；而递归是把问题逐级分解，是纵向的拆分。

---

# 递归与分治的区别

- 递归是一种编程技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体问题的算法思想。

# 常见的贪心有两种。

- 我们将 XXX 按照某某顺序排序，然后按某种顺序（例如从小到大）选择.
- 我们每次都取 XXX 中最大/小的东西，并更新 XXX。（有时「XXX 中最大/小的东西」可以优化，比如用优先队列维护）
  二者的区别在于一种是离线的，先处理后选择；一种是在线的，边处理边选择。

---

# 贪心与动态规划的区别

- 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。
---
# 前缀和
- 前缀和是一种重要的预处理，能大大降低查询的时间复杂度。可以简单理解为“数列的前n项的和”