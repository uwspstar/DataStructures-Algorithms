插入排序（Insertion Sort）是一种简单直观的排序算法，其工作原理类似于人们整理扑克牌的方法：每次将一张牌插入到已经排序好的牌中。插入排序在少量元素的排序中表现优异，具有稳定性。

### 插入排序的工作原理

1. 从第二个元素开始，假设前面的元素已经排序。
2. 将当前元素与前面的元素逐个比较，找到插入位置并插入。
3. 重复上述步骤，直到所有元素都插入到正确的位置。

### 插入排序的实现

#### Python代码示例

```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        # 将key插入到已经排序好的部分
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

# 测试插入排序
arr = [12, 11, 13, 5, 6]
print("Unsorted array:", arr)
sorted_arr = insertion_sort(arr)
print("Sorted array:", sorted_arr)
```

### 详细过程解释

1. **初始数组**：`[12, 11, 13, 5, 6]`

2. **第一步**（将11插入到前面的排序部分）：
   - `key = 11`
   - 比较11和12，发现11小于12，交换位置
   - 数组变为`[11, 12, 13, 5, 6]`

3. **第二步**（将13插入到前面的排序部分）：
   - `key = 13`
   - 13大于12，不需要移动
   - 数组保持`[11, 12, 13, 5, 6]`

4. **第三步**（将5插入到前面的排序部分）：
   - `key = 5`
   - 比较5和13，发现5小于13，移动13
   - 比较5和12，发现5小于12，移动12
   - 比较5和11，发现5小于11，移动11
   - 数组变为`[5, 11, 12, 13, 6]`

5. **第四步**（将6插入到前面的排序部分）：
   - `key = 6`
   - 比较6和13，发现6小于13，移动13
   - 比较6和12，发现6小于12，移动12
   - 比较6和11，发现6小于11，移动11
   - 数组变为`[5, 6, 11, 12, 13]`

### 复杂度分析

- **时间复杂度**：
  - 最好情况：`O(n)`（当数组已经排序时，只需要比较，不需要移动元素）
  - 平均情况：`O(n^2)`（需要比较和移动元素）
  - 最坏情况：`O(n^2)`（当数组是反向排序时，需要最大次数的比较和移动）

- **空间复杂度**：`O(1)`（使用常量级别的额外空间）

### 插入排序的特点

1. **稳定性**：插入排序是稳定的，因为相等的元素不会交换位置。
2. **适用性**：适用于小规模数据排序，或者部分有序的数据排序。
3. **在线算法**：可以在接收数据的同时进行排序。

### 适用场景

- 当数据集较小且基本有序时，插入排序效率较高。
- 插入排序在实现简单排序算法（如桶排序）的步骤中也很有用。

### 小结

插入排序是一种简单且直观的排序算法，尽管其时间复杂度在大多数情况下为`O(n^2)`，但在处理小规模数据集和部分有序数据时表现良好。它的稳定性和低空间复杂度使其在某些特定场景中非常有用。

如果有其他问题或需要进一步的解释，请随时告诉我。
