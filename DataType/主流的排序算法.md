主流的排序算法如快速排序（Quick Sort）、归并排序（Merge Sort）和堆排序（Heap Sort）通常具有 \(O(n \log n)\) 的时间复杂度。下面对这些算法进行详细介绍，包括它们的工作原理、时间复杂度分析以及优缺点。

### 快速排序（Quick Sort）

快速排序是一种基于分治法的排序算法。它通过选择一个基准元素，将数组分为两部分，一部分小于基准元素，另一部分大于基准元素，然后递归地对这两部分进行排序。

#### 工作原理
1. 选择基准元素（Pivot）。
2. 分区操作：将小于基准元素的元素放在基准元素的左边，大于基准元素的元素放在基准元素的右边。
3. 递归地对左半部分和右半部分进行排序。

#### 时间复杂度
- 最好情况：\(O(n \log n)\)（每次分区都能均匀分割数组）
- 平均情况：\(O(n \log n)\)
- 最坏情况：\(O(n^2)\)（每次选择的基准都是最小或最大元素，导致不均匀分割）

#### 优缺点
- **优点**：平均情况下性能很好，常数因子较小，适用于大多数数据集。
- **缺点**：最坏情况下时间复杂度较高；递归实现可能导致栈溢出。

### 归并排序（Merge Sort）

归并排序也是一种基于分治法的排序算法。它将数组分成两部分，分别排序后合并。

#### 工作原理
1. 将数组分成两半。
2. 递归地对每一半进行排序。
3. 合并两个已排序的子数组。

#### 时间复杂度
- 最好情况、平均情况和最坏情况：\(O(n \log n)\)

#### 优缺点
- **优点**：性能稳定，时间复杂度始终为 \(O(n \log n)\)；适用于排序链表。
- **缺点**：空间复杂度较高，需要额外的内存空间来存储合并后的数组。

### 堆排序（Heap Sort）

堆排序是一种基于堆（Heap）数据结构的排序算法。它首先将数组构建成一个最大堆（Max Heap），然后逐步将堆顶元素（最大值）移到数组末尾，并重新调整堆。

#### 工作原理
1. 构建最大堆。
2. 将堆顶元素（最大值）移到数组末尾，并减少堆的大小。
3. 调整堆，确保堆的性质。

#### 时间复杂度
- 最好情况、平均情况和最坏情况：\(O(n \log n)\)

#### 优缺点
- **优点**：时间复杂度稳定；不需要额外的内存空间（就地排序）。
- **缺点**：常数因子较大；对于已排序的数组，效率不如快速排序。

### 示例代码

#### 快速排序

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    else:
        pivot = arr[len(arr) // 2]
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        return quick_sort(left) + middle + quick_sort(right)

# 测试快速排序
arr = [12, 11, 13, 5, 6, 7]
print("Quick Sort:", quick_sort(arr))
```

#### 归并排序

```python
def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left_half = arr[:mid]
        right_half = arr[mid:]

        merge_sort(left_half)
        merge_sort(right_half)

        i = j = k = 0

        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                arr[k] = left_half[i]
                i += 1
            else:
                arr[k] = right_half[j]
                j += 1
            k += 1

        while i < len(left_half):
            arr[k] = left_half[i]
            i += 1
            k += 1

        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1

    return arr

# 测试归并排序
arr = [12, 11, 13, 5, 6, 7]
print("Merge Sort:", merge_sort(arr))
```

#### 堆排序

```python
def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[largest] < arr[left]:
        largest = left

    if right < n and arr[largest] < arr[right]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0)

    return arr

# 测试堆排序
arr = [12, 11, 13, 5, 6, 7]
print("Heap Sort:", heap_sort(arr))
```

### 总结

主流排序算法（快速排序、归并排序和堆排序）在大多数情况下都能达到 \(O(n \log n)\) 的时间复杂度，适用于各种规模的数据集。选择哪种排序算法取决于具体的应用场景和数据特性。例如，快速排序在一般情况下表现优异，但在最坏情况下可能会退化为 \(O(n^2)\)；归并排序提供稳定的性能，但需要额外的内存空间；堆排序则在时间复杂度上稳定且空间效率较高。

理解这些排序算法及其实现有助于在不同的应用场景中选择最合适的排序方法。如果有其他问题或需要进一步的解释，请随时告诉我。
